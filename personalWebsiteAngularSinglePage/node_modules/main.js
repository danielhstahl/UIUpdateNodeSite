"use strict";
var fullDistribution=require('fullDistribution');
var gaussianCF=require('GaussianCF');
var lgdCF=require('lgdCF');
var lpmCF=require('lpmCF');
var Gamma=require('Gamma');
var IntegroVasicekMG=require('IntegroVasicekMG');
var FangOosterlee=require('FangOosterlee'); //exportable class
var Complex=require('Complex'); //exportable class
//var options=JSON.parse(process.argv[2]); //command line arguments...I hope this works!
//var options=process.argv.splice(2); //command line arguments...I hope this works!
process.on('message', function(options){
    //process.send(msg);
    
    


/*process.stdin.resume();
process.stdin.on('data', function(data){
    console.log(data);
});*/


//console.log(options.lambda0);
//console.log(options[0]);//.lambda0);
//temporary main function
//var main=function(){
    //var CharFunc=CharFunction();
	/*var n=10000;
	var m=3;
	var alpha=[];
	var sigma=[];
	var y0=[];
	var rho=[[]];
	var tau=1;
	alpha[0]=.2;
	alpha[1]=.3;
	alpha[2]=.4;
	sigma[0]=.15;
	sigma[1]=.1;
	sigma[2]=.2;
	y0[0]=.9;
	y0[1]=1;
	y0[2]=1.1;
	rho[0]=[];
	rho[1]=[];
	rho[2]=[];
	rho[0][0]=1;
	rho[1][1]=1;
	rho[2][2]=1;
	rho[0][1]=.2;
	rho[1][0]=.2;
	rho[0][2]=-.3;
	rho[2][0]=-.3;
	rho[1][2]=.1;
	rho[2][1]=.1;
	var x0=.6;
	var systemicRisk=new IntegroVasicekMG(alpha, sigma, rho, y0, tau);
	var alphL=.2;
	var bL=.5;
	var sigL=.2;
	var sumL=0;
	var p=[];
	var l=[];
	var w=[];
	for(var i=0; i<n; i++){
		p[i]=.03*Math.random()+.0001;
		var lMap={};
		lMap.exposure=40000*Math.random()+1000;
		lMap.alpha=alphL;
		lMap.b=bL;
		lMap.sigma=sigL;
		lMap.t=tau;
		lMap.x0=bL; //doesnt HAVE to be bL
		l[i]=lMap;
		sumL=sumL+lMap.exposure;
		var wi=[];
		var wDen=0;
		for(var j=0; j<m; j++){
			wi[j]=Math.random();
			wDen=wi[j]+wDen;
		}
		for(var j=0; j<m; j++){
			wi[j]=wi[j]/wDen;
		}
		w[i]=wi;
	}
	var lambda=.02*sumL;
	var q=10.0/sumL;
	var options={};
	options.w=w;
	options.lambda0=lambda;
	options.q=q;
    */

    var p=[];
    var l=[];
    var w=[];
    var r=[];
    var b=[];
    var max=options.maxPD;
    var min=options.minPD;
    for(var i=0; i<options.n; i++){
        p[i]=Math.random()*(max-min)+min;
        r[i]=0;
        w[i]=[1];
        b[i]=0;
        //l[i]={a:options.a, b:options.b}; //for gamma
        l[i]={exposure:options.maxL*Math.random()+options.minL, alpha:options.mu, b:options.b, sigma:options.v, t:options.t, x0:options.b}; //for CIR
        //w.push([1]);
    }
    var lgd=lgdCF;    
    var systemicRisk=new IntegroVasicekMG(options.alpha, options.sigma, options.rho, options.y0, options.t);
	var idiosyncraticRisk=new lpmCF(lgd, p, l, {w:options.w, b:b, r:r, lambda0:options.lambda0, q:options.q});
	//var mu=options.n*l[0].a*l[0].b*options.alph*options.maxPD;//for gamma
	var mu=options.n*options.maxL*options.alph*options.maxPD;//for cir
	var sigma=0;//mu/4;
	var optGauss={};
	optGauss.w=[1, 0, 0];
	var returnAndVolatility=new gaussianCF(mu, sigma, optGauss);
	console.log(mu);
	//console.log(returnAndVolatility.logCF(new Complex(.5, .5)));
	var logDist=[];
	logDist[0]=idiosyncraticRisk;
	logDist[1]=returnAndVolatility;
	//logDist[0]=returnAndVolatility;
	var fullDist=new fullDistribution(systemicRisk, logDist);
	//console.log(fullDist.execute(new Complex(.5, .5)).real);

	var computeDist=new FangOosterlee(options.k, options.h);
	var xmax=mu;
	var xmin=-options.lambda0-(mu/options.alph)*1.6; //very rough....
	//xmin=-8;
	//xmax=10;
	
	var startTime = new Date();
	var distribution=computeDist.computeDistribution(fullDist, xmin, xmax);
	//var distribution=computeDist.computeDistribution(returnAndVolatility, xmin, xmax);
	var endTime=new Date()-startTime;
	console.log(endTime/1000);
	//console.log(distribution);
	process.send({result:distribution});
    
 });   
    
//}
//module.exports=main; //exportable class...TEMPORARY