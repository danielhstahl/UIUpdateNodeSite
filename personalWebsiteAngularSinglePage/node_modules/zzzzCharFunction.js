"use strict";
var Complex=require('Complex'); //exportable class
var CharFunction=function(){
    var lgdCF=function( options){ //exposure, alpha, b, sigma, t, x0...dx=alpha(b-x)dt+sigma sqrt(x) dw
        this.l=options.exposure;
        this.lambda=options.alpha;
        this.theta=options.b;
        this.sigma=options.sigma;
        this.t=options.t;
        this.x0=options.x0;
    }
    lgdCF.prototype.execute=function(u){
        
        u=u.multiply(new Complex(this.l, 0));
        var uP=u.multiply(new Complex(-(.5*this.sigma*this.sigma/this.lambda)*(1.0-Math.exp(-this.lambda*this.t)), 0)).add(new Complex(1.0, 0));
        return u.multiply(new Complex(Math.exp(-this.lambda*this.t)*this.x0, 0)).divide(uP).exp().multiply(uP.power(-(2*this.lambda*this.theta)/(this.sigma*this.sigma)));
    }
    var lpmCF=function(p, l, options){ //p, l, w, r, b, lambda0, q..l[i] is an associate array containing varaibles for lgdCF
        //var self=this;
        this.p=p;
        this.n=this.p.length;
        this.l=l;
        var notUsed={};
        var notUsedKeys=[];
        if(options.w){
            this.w=options.w;
        }	
        else{
            this.w=[];
            notUsed["w"]=[1];
            notUsedKeys.push("w");
        }
        if(options.b){
            this.b=options.b;
        }
        else {
            this.b=[];
            notUsed["b"]=0;
            notUsedKeys.push("b");
        }
        if(options.r){
            
            this.r=options.r;
        }
        else {
            this.r=[];
            notUsed["r"]=0;
            notUsedKeys.push("r");
        }
        if(options.lambda0){
            this.lambda0=options.lambda0;
        }
        else {
            this.lambda0=0;
        }
        if(options.q){
            this.q=options.q;
        }
        else {
            this.q=0;
        }
        this.lambda=this.lambda0;
        var m=notUsedKeys.length;
        var nn=this.n; //speed purposes
        for(var i=0; i<nn; i++){	
            for(var j=0; j<m; j++){
                //console.log(notUsedKeys[j]);
                //self[notUsedKeys[j]][i]=notUsed[notUsedKeys[j]];
                this[notUsedKeys[j]][i]=notUsed[notUsedKeys[j]];
            }
            this.lambda=this.lambda+this.r[i]*this.b[i];
        }
        this.m=this.w[0].length;
    }
    lpmCF.prototype.logCF=function(u){
        var v=[];
        var upperU=u.multiply(new Complex(-this.lambda, 0));
        upperU=upperU.exp().subtract(new Complex(1.0, 0)).multiply(new Complex(this.q, 0));
        upperU=upperU.subtract(u);
        var helperPhi=[];
        v[0]=new Complex(0, 0);
        var nn=this.n;//for speed purposes
        var mm=this.m;//for speed 
        for(var i=0; i<nn; i++){
            var li=this.l[i];//for speed purposes
            var phiL=new lgdCF(li);
            helperPhi[i]=phiL.execute(upperU).subtract(new Complex(1.0, 0)).multiply(new Complex(this.p[i], 0));
            v[0]=v[0].add(helperPhi[i].multiply(new Complex(this.w[i][0], 0)));
        }
        for(var j=1; j<mm; j++){
            v[j]=new Complex(0, 0);
            for(var i=0; i<nn; i++){
                v[j]=v[j].add(helperPhi[i].multiply(new Complex(this.w[i][j], 0)));
            }
        }
        return v;
    }
    lpmCF.prototype.getM=function(){
        return this.m;
    }

    var IntegroVasicekMG=function(alpha, sigma, rho, y0, tau){ //systemic risk
        this.m=alpha.length;
        function helpComputeMoments(a){
            return ((1-Math.exp(-a*tau))/a);
        }
        this.variance=[];
        this.expectation=[];
        this.computeMGF=function(v){
            var mm=this.m;//for speed purposes
            for(var i=0; i<mm; i++){
                this.variance[i]=[];
                var ai=helpComputeMoments(alpha[i]);
                this.expectation[i]=(y0[i]-1.0)*ai+tau;
                for(var j=0; j<mm; j++){
                    var aj=helpComputeMoments(alpha[j]);
                    var helpVarij=(rho[i][j]*sigma[i]*sigma[j]/(alpha[i]*alpha[j]))*(tau-ai-aj+(1-Math.exp(-(alpha[i]+alpha[j])*tau))/(alpha[i]+alpha[j])); //difra page 10
                    this.variance[i][j]=helpVarij;
                }
            }
        }
    }
    IntegroVasicekMG.prototype.execute=function(v){ //vector of u
        var el=new Complex(0, 0);
        var vl=new Complex(0, 0);
        
        if(!this.variance[0]){
            this.computeMGF();
        }
        var mm=this.m;
        for(var i=0; i<mm; i++){
            el=el.add(v[i].multiply(new Complex(this.expectation[i], 0)));
            for(var j=0; j<mm; j++){
                vl=vl.add(v[i].multiply(v[j]).multiply(new Complex(this.variance[i][j], 0)));
            }
        }
        vl=vl.multiply(new Complex(.5, 0)).add(el);
        return vl.exp();
    }

    var fullDistribution=function(vasM, logClasses){ //takes IntegroVasicekMG and an array of charactersitic functions as arguments
        this.vasM=vasM;
        this.logClasses=logClasses;
        this.m=logClasses[0].getM();
        this.n=logClasses.length;
        this.totalLogCF=[];
    }
    fullDistribution.prototype.execute=function(u){
        var vct=[];
        var nn=this.n;//for speed
        var mm=this.m;//for speed
        for(var i=0; i<nn; i++){
            vct[i]=this.logClasses[i].logCF(u); //all classes should have logCF!
        }
        for(var j=0; j<mm; j++){
            plc=new Complex(0, 0);
            for(var i=0; i<nn; i++){
                plc=plc.add(vct[i][j]);
            }
            this.totalLogCF[j]=plc;
        }
        return this.vasM.execute(this.totalLogCF);
    }
    fullDistribution.prototype.getM=function(){
        return this.m;
    }

    var gaussianCF=function(mu, sigma, options){
        if(options.w){
            this.w=options.w;
        }
        else{
            this.w=[1];
        }
        this.mu=mu;
        this.sigma=sigma;
        this.m=this.w.length;
    }
    gaussianCF.prototype.logCF=function(u){	
        var returnValue=[];
        for(var i=0;i<this.m;i++){
            var mu=this.w[i]*this.mu;
            var sigma=this.w[i]*this.sigma;
            returnValue[i]=u.multiply(new Complex(mu, 0)).add(u.multiply(u).multiply(new Complex(sigma*sigma*.5, 0)));
        }
        return returnValue;

    }
    gaussianCF.prototype.execute=function(u){	
        var returnValue=u.multiply(new Complex(this.mu, 0)).add(u.multiply(u).multiply(new Complex(this.sigma*this.sigma*.5, 0))).exp();
        return returnValue;

    }
    gaussianCF.prototype.getM=function(){
        return this.m;
    }
}
module.exports=CharFunction;
