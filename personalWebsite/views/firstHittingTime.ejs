<html>
    <head>
        <meta name="contentType" content="research">        <meta name="keywords" content="firstHitting">        <meta name="description" content="Description of First Hitting Time Density">
        <% include  assets/includes/header %>
    </head>


    <body>     
    <div class='navbar-fixed-top' >
        <!--<div class='col-xs-8 col-xs-offset-2 title'>-->        <div class='container title lead'>
            <h1>The Density of the First Hitting Time</h1>
        </div>
    </div>
    <div class='disclaimer'>
        Disclaimer: Rigor is sacrificed for the sake of clarity.  Most proofs or derivations are heuristic.
    </div>
    <div class='container'> <!--used to have a container here -->
        <div class='col-xs-12 col-md-8 '>             <div class='txt'>                This page describes how to numerically compute the density of the first hitting time of a CEV process.  See <a href='<% include assets/includes/scrapeSimilar %>'>first hitting time density project</a> for the application that displays this density.            </div>
            <div class='title lead'><h2>Introduction</h2> </div>            <div class='txt'>
                In a continuous setting, the "first hitting time" of a process is defined as the first time a process \(X_t\) is equal to a level \(m\).  If the process is random, the first hitting time (denoted \(\tau_m \)) is also random.  With few exceptions, the density of the first hitting time of even a single dimensional Stochastic Differential Equation (SDE) is not explicitly known.  However, finding the distribution numerically is not computationally difficult.  The technique involves the characteristic function of \(X_t\).  The next section explains characteristic functions and their use with a simple example.            </div>
            
            <div class='title lead'><h2>Characteristic functions explained</h2></div>             <div class='txt'>
                The characteristic function of a random variable \(X\) is defined as \[\phi(u)=\mathbb{E}\left[e^{uiX}\right]=\int_\Omega e^{uiX} d\mathbb{P}(\omega)=\int_{\mathbb{R}} e^{uix} f(x) dx\]  The last equality assumes that the random variable \(X\) has a density function \(f(x)\). By Fourier's inversion theorem, \[\frac{1}{2\pi} \int_\mathbb{R} e^{-iux} \phi(u) du = f(x) \]
            </div>
            <div class='subTitle lead'><h3>Simple Example</h3> </div>
                        <div class='txt'>
                The density of a normal random variable with mean \(\mu\)and variance \( \sigma^2 \)is 
                \[f(x)=\frac{1}{\sqrt{2\pi} \sigma} e^{-\frac{(x-\mu)^2}{2\sigma^2}}\]
                The characteristic function is 
                \[\phi(u)= e^{u \mu i - \frac{\sigma^2 u ^2}{2}}\]
                To demonstrate the Fourier inversion theorem, we will invert \(\phi(u)\) to recover \(f(x)\)
                \[\frac{1}{2\pi} \int_\mathbb{R} e^{-iux} e^{u \mu i - \frac{\sigma^2 u^2}{2}} du \]
                \[=\frac{1}{2\pi} \int_\mathbb{R} e^{ui (\mu-x) - \frac{\sigma^2 u^2}{2}} du \]
                \[=\frac{1}{2\pi} \int_\mathbb{R} e^{- \frac{\sigma^2}{2}\left(u-\frac{(\mu-x)i}{\sigma^2}\right)^2 -\frac{1}{2\sigma^2}(\mu-x)^2 } du \]
                \[=\frac{1}{\sqrt{2\pi}}e^{-\frac{1}{2\sigma^2}(x-\mu)^2 } \int_\mathbb{R} \frac{1}{\sqrt{2\pi}}e^{- \frac{z^2}{2} } \frac{dz}{\sigma} \]
                Where \(z=\sigma\left(u-\frac{(\mu-x)i}{\sigma^2}\right)\) and \(dz=\sigma du\).  
                \[=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{1}{2\sigma^2}(x-\mu)^2 } \int_\mathbb{R} \frac{1}{\sqrt{2\pi}}e^{- \frac{z^2}{2} } dz \]
                \[=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{1}{2\sigma^2}(x-\mu)^2 } \]            </div>
            
            <div class='title lead'><h2>First Hitting Time</h2> </div>            <div class='txt'>
                In what follows, the driving process is \(X_t\) which solves the SDE \( dX=\alpha(X_t, t)dt+\sigma(X_t, t)dW_t \) with initial value \(X_0\).  This is the most general process in a diffusion setting.            </div>

            <div class='subTitle lead'><h3>Dynkan's Formula</h3></div>            <div class='txt'>
                Dynkan's formula states the following:
                \[ \mathbb{E}[g(X_\tau)]=g(X_0)+\mathbb{E}\left[\int_0 ^ \tau \mathcal{A}g dt \right]\]
            
                Where \( \mathcal{A}=\alpha(x, t)\frac{\partial }{\partial x} + \sigma^2(x, t) \frac{1}{2} \frac{\partial^2}{\partial x^2}\) is the generator of \( X_t\) and \( \tau \) is a stopping time with respect the filtration generated by the Brownian motion.             </div>
           
            <div class='subTitle lead'><h3>Finding the Characteristic Function of \(\tau\)</h3></div>            <div class='txt'>
            
                The characteristic function of a random variable \(\tau_m\) can be numerically inverted to recover the density.  Recalling that the characteristic function is defined as 
                \[\phi(u)=\mathbb{E}\left[e^{ui\tau}\right]\] and letting \( g(X_t)=e^{uit}h(X_t)\), then by Dynkan's formula we have 
                \[\phi(u)=\mathbb{E}[e^{ui\tau_m}]=h(X_0)+\int_0 ^ {\tau_m} \left(\mathcal{A}h+uih\right) dt\]
            
                With \( h(X_\tau)=h(m)=1 \).  \( \phi(u) \) is then the solution to the ODE 
                \[ \mathcal{A}\phi+ui\phi=0\]
          
                With terminal condition \(\phi(m)=1 \).  This ODE can be efficiently solved numerically (eg, by using finite difference methods) and then numerically inverted to obtain the density function of \(\tau\).  Discretizing the ODE and solving it numerically is has linear complexity as will be shown below. Solving the ODE in this way yields the approximate solution for \(x \in (0,m)\), but only for a single value of \(u\). Therefore the ODE must be solved multiple times in order to obtain the characteristic function for each discretized \(u\). Fortunately once the matrix of values is obtained the density function can be recovered for each discretized \(x \in (0,m)\).  The total complexity for computing the matrix is \(O(l * n)\) where \(l\) is the number of steps in \(u\) and \(n\) is the number of steps in \(x\).            </div>
           
            <div class='subTitle lead'><h3>Simple Example</h3> </div>            <div class='txt'>
                For simplicity, let \(dX=\alpha X dt+\sigma X^{\delta} dW_t \).  This corresponds with the CEV model for stock price movements and is chosen due to being a relatively simple but interesting case: there are no analytic solutions to the distribution of the first hitting time.  The ODE that solves the characteristic function is 
                \[\left\{ \begin{array}{l}\alpha x \frac{\partial \phi}{\partial x} +\frac{x^{2\delta}\sigma^2}{2}  \frac{\partial^2 \phi}{\partial x ^2}+ui\phi=0\\ \phi(m)=1 \end{array} \right. \]
           
                Using finite difference methods, the equation is discretized as follows (for \(j=1,...n-1 \)): 
                \[\left\{ \begin{array}{l} x \approx x_0+\Delta x j =x_j\\ \frac{\partial \phi}{\partial x} \approx \frac{\phi(x_0+\Delta x (j+1))-\phi(x_0+\Delta x (j-1))}{2\Delta x} = \frac{\phi_{j+1}-\phi_{j-1}}{2\Delta x} \\ \frac{\partial^2 \phi}{\partial x ^2} \approx \frac{\phi(x_0+\Delta x (j+1))-2\phi(x_0+\Delta x j)+\phi(x_0+\Delta x (j-1))}{(\Delta x)^2} =\frac{\phi_{j+1}-2\phi_j+\phi_{j-1} }{(\Delta x) ^2}\end{array} \right. \]
                Substituting these into the ODE, the result is the following:
                \[\alpha x_j \frac{\phi_{j+1}-\phi_{j-1}}{2\Delta x} +\frac{x_j ^{2\delta}\sigma^2}{2}  \frac{\phi_{j+1}-2\phi_j+\phi_{j-1} }{(\Delta x) ^2}+ui\phi_j=0\]
                Grouping all the like terms,
                \[\left\{ \begin{array}{l} \left(\frac{x_j ^{2\delta} \sigma^2}{2(\Delta x)^2}+\frac{\alpha x_j}{2\Delta x}\right)\phi_{j+1}=b_j \phi_{j+1}\\ \left(ui-\frac{x_j ^{2\delta} \sigma^2}{(\Delta x)^2}\right)\phi_{j}=a_j \phi_{j}\\ \left(\frac{x_j ^{2\delta} \sigma^2}{2(\Delta x)^2}-\frac{\alpha x_j}{2\Delta x}\right)\phi_{j-1}=c_j \phi_{j-1}  \end{array} \right. \] 
                This can be represented by the following tri-diagonal matrix equation:
                \[ \left[\begin{array}{cccc} a_1 & b_1 & 0 &  \ldots \\  c_2 & a_2 & b_2 &  \ldots \\  0 & c_3 & a_3  & \ddots  \\ \vdots & \vdots  & \ddots & \ddots \end{array} \right] \left[\begin{array} {c} \phi_1 \\ \phi_2 \\ \phi_2 \\ \vdots \end{array}\right]     \]
                With \( \phi_0=0,\phi_n=1 \). To incorporate these boundary conditions, the solution of the matrix equation is 
                \[\left[\begin{array} {c} 0 \\ \vdots \\ 0 \\ -b_{n-1} \end{array}\right]\]
                Since this matrix is tri-diagonal, it can be solved in \(O(n) \) operations using the Thomas algorithm.  The following code shows the Thomas algorithm in javascript:            
            <pre><code class="language-javascript txt"> 
function thomas(a, b, c, psi){ //a, b, c, psi are vectors, a is complex
    //if b.length=a.length or c.length=a.length, only first n-1 records are used
    var n=a.length; //get number of records on diagonal
    for(var i=1<i>;</i> i<i><</i>n<i>;</i> i++){ //forward loop 
        var gamHat= math.divide(c[i-1], a[i-1]);
        a[i]=math.add(a[i], math.multiply(-b[i-1],gamHat)); 
        psi[i]=math.add(psi[i], math.multiply(-psi[i-1], gamHat));
    }
    var phi=new Array(n+2); //the solution 
    phi[n]=math.divide(psi[n-1], a[n-1]);  
    phi[0]=0; //boundaries
    phi[n+1]=1;//boundaries
    for(var i=(n-2); i>-1; i--){ //backward loop
        phi[i+1]=math.divide(math.add(psi[i], math.multiply(-b[i], phi[i+2])), a[i]); 
        phi[i+2]=math.re(phi[i+2]); //only keep real part
    }
    phi[1]=math.re(phi[1]); //only keep real part
    return phi;
}  
            </code> </pre>
            This function numerically computes the ODE.
            <pre><code class="language-javascript txt">
function ode(n, alpha, sigma, mu, delta, m){ //number of discrete steps, drift, volatility, complex term, CEV parameter, barrier.
    var dx=m/(n-1); //the domain is [0, m] since a CEV process is always positive.
    var a=new Array(n-2);//first and last are boundary conditions
    var b=new Array(n-2);//first and last are boundary conditions
    var c=new Array(n-2);//first and last are boundary conditions
    var psi=new Array(n-2);//first and last are boundary conditions
    var sigs=(sigma*sigma)/(dx*dx);
    for(var i=0<i>;</i> i<(n-2)<i>;</i> i++){ //first and last are boundary conditions
        a[i]=math.subtract(math.complex(0, mu), math.pow(dx*(i+1), 2*delta)*sigs); 
        b[i]=math.pow(dx*(i+1), 2*delta)*.5*sigs+.5*alpha*(i+1);
        c[i]=math.pow(dx*(i+2), 2*delta)*.5*sigs-.5*alpha*(i+2); //note that x_{j+1} instead of x_j
        psi[i]=0;
    } 
    psi[n-3]=-b[n-3]; //boundary condition
    var phi=thomas(a, b, c, psi); //solve equation
    return phi;
} 
            </code></pre>
                Oosterlee and Fang (2008) proposed a novel method to price European options for a very diverse set of asset models. This method relies on inverting the characteristic function of the underlying log price; and prices options with many strikes simultaneously. Along the way they demonstrated the surprising accuracy of the method in computing the probability density from the characteristic function. Since the authors’ main goal was to price options they spent minimal time on this result.  Two key characteristics of this algorithm are the separate computations of the \(x\) and \(u\) domains and the exponential convergence of the algorithm. The method that the authors devised only requires \(O(nlk)\) operations to compute the density where \(k\) is the number of steps in the \(\tau\) domain and due to the excellent convergence properties \(l\) does not typically have to be larger than \(128\).
            <pre><code class="language-javascript txt">
 //function FangOosterlee(l, k, n, m, alpha, delta, sigma, X0, domObject){ //l is the number of u discretions, k is number of t-discretions, n is the discretions in the ODE solution, m is the hitting value, alpha is the drift of dX, delta is the power of X (a value of one corresponds to B-S), and sigma is the volatility
function FangOosterlee(options){ 
    var n=options['n'];
    var k=options['k'];
    var l=options['l'];
    var m=options['m'];
    var alpha=options['alpha'];
    var delta=options['delta'];
    var sigma=options['sigma'];
    var X0=m*.2;//hardcoded X0 for the sake of determining the size of t-space.  This is not suitable for production!
    var exVal=math.abs(math.log(m/X0)/(alpha-.5*sigma*sigma)); //expected value of tau when delta=1, used for determining size of t-space
    var std=math.sqrt(math.abs((math.log(m/X0)*sigma*sigma)/(math.pow(alpha-.5*sigma*sigma, 3)))); //standard deviation of tau when delta=1, used for determining size of t-space
    var xMax=exVal+5*std; //a range for t-space...production code would would chebyshev's inequality to compute the range instead of an arbitrary "5"
    var lam=xMax/(k-1);//"dt"
    var dx=m/(n-1); //"dx"
    var du=Math.PI/xMax; //discrete u
    var cp=2/xMax; 
    var phi=[];//array of arrays...
    var initial=ode(n, alpha, sigma, 0, delta, m); //get solution of ODE for each u...this is not included in for loop since we need to multiply by .5
    for(var i=0<i>;</i> i<i><</i>n<i>;</i> i++){
        initial[i]=initial[i]*.5;
    }
    var denominator=n+l-1;
    phi.push(initial);
    for(var i=1<i>;</i> i<i><</i>l<i>;</i> i++){
        var updateRatio=(i*100)/denominator;
        self.postMessage({update: updateRatio+'%'}); //since this is a long running task, this is called asynchronously and posts updates of progress to the original thread
        phi.push(ode(n, alpha, sigma, i*du, delta, m)); //get solution of ODE for each u
    }
    var soFar=i;
    var data={}; 
    for(var h=0<i>;</i> h<i><</i>n<i>;</i> h++){ 
        var updateRatio=((soFar+h)*100)/denominator;
        self.postMessage({update: updateRatio+'%'});  
        var key=Math.round(dx*h*10000)/10000.0;  
        key=key.toString();
        data[key]=[]; 
        var ySeries=[];
        var xSeries=[];
        for(var i=0<i>;</i> i<i><</i>k<i>;</i> i++){ //iterate over "t" discretions
            var y=0;
            for(var j=0<i>;</i> j<i><</i>n<i>;</i> j++){
                y=y+phi[j][h]*math.cos(du*j*lam*i)*cp;
            }  
            ySeries.push(y ); 
            xSeries.push(i*lam); 
        }
        data[key]={Time: xSeries, Values: ySeries}; //put data in a manner that is easily readable
    }
    self.postMessage( {result:data});
}            
            </code></pre>
        </div>
        </div>
      
    </div>
    <div id="chart">
    </div>
    <% include  assets/includes/menu %><!--side menu -->
    </body>
    <% include  assets/includes/footerScripts %> <!--final includes for side menu -->
    <script>
        
    </script>
</head>
